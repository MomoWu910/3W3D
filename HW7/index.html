<!DOCTYPE html>
<html>
	<head>
		<style>
			#info {
				position: absolute;
				top: 0px;
				width: 100%;
				padding: 10px;
				text-align: center;
				color: #ffff00
			}
			body {
				overflow: hidden;
			}
		</style>
	</head>

	<body>
		
		<script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js"></script>
		<script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js"></script>
		<script id="vertexShader" type="x-shader/x-vertex">
			varying vec2 vUv;
			
			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
		<script id="fragmentShader" type="x-shader/x-fragment">
			uniform float time;
			varying vec2 vUv;
			
			float rand(vec2 co) {
				return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
			}

			void main(void) {
				// Divide the coordinates into a grid of squares
				vec2 v = vUv*10.0; //gl_FragCoord.xy / 20.0;
				// Calculate a pseudo-random brightness value for each square
				vec3 brightness = vec3(fract(rand(floor(v)) + time), fract(rand(floor(v)) + time / 3.), fract(rand(floor(v)) + time / 5.));
				// Reduce brightness in pixels away from the square center
				brightness *= 0.5 - length(fract(v) - vec2(0.5, 0.5));
				gl_FragColor = vec4(brightness.r * 4.0, brightness.g * brightness.b * 2., brightness.b - brightness.r + 0.2, 1.0);
			}
		</script>
		<script id="vertexShader2" type="x-shader/x-vertex">
			varying vec2 vUv;
			
			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
		<script id="fragmentShader2" type="x-shader/x-fragment">
			
			varying vec2 vUv;
			uniform float time;
			
			float rand(vec2 co){
			  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
			}
			
			void main (void) {
				// Divide the coordinates into a grid of squares
				vec2 v = vUv*10.0; //gl_FragCoord.xy / 20.0;
				// Calculate a pseudo-random brightness value for each square
				float brightness = fract(rand(floor(v)) + time);
				// Reduce brightness in pixels away from the square center
				brightness *= 0.5 - length(fract(v) - vec2(0.5, 0.5));
				gl_FragColor = vec4(brightness * 10.0, brightness * 10.0, brightness * 10.0, 0.0);
			}
		</script>
		<script id="vertexShader3" type="x-shader/x-vertex">
			varying vec2 vUv;
			
			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
		<script id="fragmentShader3" type="x-shader/x-fragment">
			
			varying vec2 vUv;
			uniform float time;
			
			float rand(vec2 co){
			  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
			}
			
			void main (void) {
				// Divide the coordinates into a grid of squares
				vec2 v = vUv*10.0; //gl_FragCoord.xy / 20.0;
				// Calculate a pseudo-random brightness value for each square
				float brightness = fract(rand(floor(v)) + time);
				// Reduce brightness in pixels away from the square center
				brightness *= 0.5 - length(fract(v) - vec2(0.5, 0.5));
				gl_FragColor = vec4(brightness * 10.0, brightness * 10.0, 0.0, 0.0);
			}
		</script>
		<script id="vertexShader4" type="x-shader/x-vertex">
			varying vec2 vUv;
			
			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
		<script id="fragmentShader4" type="x-shader/x-fragment">
			
			varying vec2 vUv;
			uniform float time;
			
			float rand(vec2 co){
			  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
			}
			
			void main (void) {
				// Divide the coordinates into a grid of squares
				vec2 v = vUv*10.0; //gl_FragCoord.xy / 20.0;
				// Calculate a pseudo-random brightness value for each square
				float brightness = fract(rand(floor(v)) + time);
				// Reduce brightness in pixels away from the square center
				brightness *= 0.5 - length(fract(v) - vec2(0.5, 0.5));
				gl_FragColor = vec4(brightness * 10.0, 0.0, brightness * 10.0, 0.0);
			}
		</script>
		<script>
			var camera, scene, renderer, geometry, geometry2, material, controls;
			var pos, vel, pColor, pointLight, pointLight2, pointLight3, pointLight4;
			var clock = new THREE.Clock();
			var meshMaterial, meshMaterial2, meshMaterial3, meshMaterial4;
			var mesh, mesh2, mesh3, mesh4, mesh5, mesh6; 
			var plane, cyl;
			var mouse = new THREE.Vector2();
			var score;


			var Puck = function (){
				this.pos = new THREE.Vector3(0, 1, 0);
				this.vel = new THREE.Vector3(50, 0, 70);
				this.mesh = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 2, 20), new THREE.MeshBasicMaterial());
			};

			Puck.prototype.update = function(dt){
				this.pos.add(this.vel.clone().multiplyScalar(dt));
				this.mesh.position.copy(this.pos);    
			};

			Puck.prototype.collision = function(){
				//var start  = clock.startTime;
				//var old = clock.oldTime;
				if (this.pos.x > 90) {
					this.pos.x = 90;
					this.vel.set(-this.vel.x, 0, this.vel.z);
					pColor.setHSL(Math.random(), Math.random(), Math.random() / 2 + 0.5);
				} else if (this.pos.x < -90) {
					this.pos.x = -90;
					this.vel.set(-this.vel.x, 0, this.vel.z);
					pColor.setHSL(Math.random(), Math.random(), Math.random() / 2 + 0.5);
				}
				if (this.pos.z > 90) {
					//if((old-start)/1000 < 5.0){
						this.pos.z = 90;
						this.vel.set(this.vel.x, 0, -this.vel.z);
						pColor.setHSL(Math.random(), Math.random(), Math.random() / 2 + 0.5);
					//}
				} else if (this.pos.z < -90) {
					//if((old-start)/1000 < 5.0){
						this.pos.z = -90;
						this.vel.set(this.vel.x, 0, -this.vel.z);
						pColor.setHSL(Math.random(), Math.random(), Math.random() / 2 + 0.5);
					//}
				}
			};
			init();
			animate();
			function init() {
				scene = new THREE.Scene();
				

				camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
				camera.position.z = 500;
				scene.add(camera);

				geometry = new THREE.BoxGeometry(200, 30, 10);
				geometry2 = new THREE.BoxGeometry(110, 30, 10);
				material = new THREE.MeshBasicMaterial({
					transparent: true,
					color: 0x000000,
					opacity: 0.6
				});

				mesh3 = new THREE.Mesh(geometry, material);
				mesh2 = new THREE.Mesh(geometry2, material);
				
				mesh = mesh2.clone();
				mesh.position.set(55, 15, -105);//top1
				scene.add(mesh);
				mesh6 = mesh2.clone();
				mesh6.position.set(-55, 15, -105);//top2
				scene.add(mesh6);
				
				mesh2.position.set(55, 15, 105);//down1
				scene.add(mesh2);
				mesh5 = mesh2.clone();
				mesh5.position.set(-55, 15, 105);//down2
				scene.add(mesh5);
				
				
				mesh3.rotation.y = Math.PI / 2;
				mesh3.position.set(105, 15, 0);//right
				scene.add(mesh3);
				mesh4 = mesh3.clone();
				mesh4.rotation.y = Math.PI / 2;
				mesh4.position.set(-105, 15, 0);//left
				scene.add(mesh4);
				
				
				meshMaterial = new THREE.ShaderMaterial({
					uniforms: {
						time: {
							type: 'f',
							value: 1.0
						}
					},
					vertexShader: document.getElementById('vertexShader').textContent,
					fragmentShader: document.getElementById('fragmentShader').textContent
				});
				meshMaterial2 = new THREE.ShaderMaterial({
					uniforms: {
						time: {
							type: 'f',
							value: 1.0
						}
					},
					vertexShader: document.getElementById('vertexShader2').textContent,
					fragmentShader: document.getElementById('fragmentShader2').textContent
				});
				meshMaterial3 = new THREE.ShaderMaterial({
					uniforms: {
						time: {
							type: 'f',
							value: 1.0
						}
					},
					vertexShader: document.getElementById('vertexShader3').textContent,
					fragmentShader: document.getElementById('fragmentShader3').textContent
				});
				meshMaterial4 = new THREE.ShaderMaterial({
					uniforms: {
						time: {
							type: 'f',
							value: 1.0
						}
					},
					vertexShader: document.getElementById('vertexShader4').textContent,
					fragmentShader: document.getElementById('fragmentShader4').textContent
				});
				
				puck = new Puck();
				puck.mesh = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 2, 20), meshMaterial);
				scene.add(puck.mesh);
				
				
				puck2 = new Puck();
				puck2.mesh = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 2, 20), meshMaterial2);
				
				
				puck3 = new Puck();
				puck3.mesh = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 2, 20), meshMaterial3);
				
				puck4 = new Puck();
				puck4.mesh = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 2, 20), meshMaterial4);
				
				ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200, 130, 130),
				new THREE.MeshLambertMaterial({
					color: 0x888888,
					side: THREE.DoubleSide
				}));

				ground.rotation.x = -Math.PI / 2;
				scene.add(ground);

				
				pColor = new THREE.Color();
				pColor.setHSL(Math.random(), Math.random(), Math.random());
				
				pointLight = new THREE.PointLight(pColor.getHex(), 1);
				pointLight2 = new THREE.PointLight(pColor.getHex(), 1);
				pointLight3 = new THREE.PointLight(pColor.getHex(), 1);
				pointLight4 = new THREE.PointLight(pColor.getHex(), 1);
				scene.add(pointLight);
				scene.add(pointLight2);
				scene.add(pointLight3);
				scene.add(pointLight4);
				
				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(0x888888);

				controls = new THREE.OrbitControls(camera, renderer.domElement);
				var ambientLight = new THREE.AmbientLight(0x111111);
				scene.add(ambientLight);
				
				var cyl_geom = new THREE.BoxGeometry(75, 10, 10);
				var cyl_mat = new THREE.MeshLambertMaterial ({color: 0xffffff});
				cyl = new THREE.Mesh (cyl_geom, cyl_mat);
				cyl.position.set (-20,10,20);
				cyl.name = "leftB";
				//scene.add (cyl);
				
				plane = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( 200, 200, 8, 8 ),
					new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.25, transparent: true } )
				);
				plane.rotation.x = -Math.PI/2;
				plane.visible = false;   // invisible, for picking only
				scene.add( plane );

				window.addEventListener ('resize', onWindowResize, false);	
				window.addEventListener( 'mousemove', onDocumentMouseMove, false );

				document.body.appendChild(renderer.domElement);
			}

			function onDocumentMouseMove( event ) {
				event.preventDefault();
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				//mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
				
				var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );
				var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

				var intersects = raycaster.intersectObject( plane );
				if (intersects.length > 0) {
					var move = intersects[0].point.clone();
					cyl.position.copy (move);
				}
			}

			function onWindowResize()
			{
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize (window.innerWidth, window.innerHeight);
			}

			/*function coll(){
				var ab = Math.sqrt((puck.pos.x - puck2.pos.x)*(puck.pos.x - puck2.pos.x) + (puck.pos.z - puck2.pos.z)*(puck.pos.z - puck2.pos.z));
				var ac = Math.sqrt((puck.pos.x - puck3.pos.x)*(puck.pos.x - puck3.pos.x) + (puck.pos.z - puck3.pos.z)*(puck.pos.z - puck3.pos.z));
				var ad = Math.sqrt((puck.pos.x - puck4.pos.x)*(puck.pos.x - puck4.pos.x) + (puck.pos.z - puck4.pos.z)*(puck.pos.z - puck4.pos.z));
				var bc = Math.sqrt((puck2.pos.x - puck3.pos.x)*(puck2.pos.x - puck3.pos.x) + (puck2.pos.z - puck3.pos.z)*(puck2.pos.z - puck3.pos.z));
				var bd = Math.sqrt((puck2.pos.x - puck4.pos.x)*(puck2.pos.x - puck4.pos.x) + (puck2.pos.z - puck4.pos.z)*(puck2.pos.z - puck4.pos.z));
				var cd = Math.sqrt((puck3.pos.x - puck4.pos.x)*(puck3.pos.x - puck4.pos.x) + (puck3.pos.z - puck4.pos.z)*(puck3.pos.z - puck4.pos.z));
				
				if(ab <= 20){
					if(puck.vel.x > 0 && puck2.vel.x > 0 && puck.vel.z > 0 && puck2.vel.z > 0){
						if(puck.pos.x > puck2.pos.x && puck.pos.z > puck2.pos.z){
							puck2.vel.set(-puck2.vel.x, 0, -puck2.vel.z); 
						}else if(puck.pos.x < puck2.pos.x && puck.pos.z < puck2.pos.z){
							puck.vel.set(-puck.vel.x, 0, -puck.vel.z);
						}else{
							puck.vel.set(-puck.vel.x, 0, -puck.vel.z);
							puck2.vel.set(-puck2.vel.x, 0, -puck2.vel.z); 
						}
					}
					puck.vel.set(-puck.vel.x, 0, -puck.vel.z);
					puck2.vel.set(-puck2.vel.x, 0, -puck2.vel.z); 
				}
				if(ac <= 20){
					puck.vel.set(-puck.vel.x, 0, -puck.vel.z);
					puck3.vel.set(-puck3.vel.x, 0, -puck3.vel.z);
				}
				if(ad <= 20){
					puck.vel.set(-puck.vel.x, 0, -puck.vel.z);
					puck4.vel.set(-puck4.vel.x, 0, -puck4.vel.z);
				}
				if(bc <= 20){
					puck2.vel.set(-puck2.vel.x, 0, -puck2.vel.z);
					puck3.vel.set(-puck3.vel.x, 0, -puck3.vel.z);
				}
				if(bd <= 20){
					puck2.vel.set(-puck2.vel.x, 0, -puck2.vel.z);
					puck4.vel.set(-puck4.vel.x, 0, -puck4.vel.z);
				}
				if(cd <= 20){
					puck3.vel.set(-puck3.vel.x, 0, -puck3.vel.z);
					puck4.vel.set(-puck4.vel.x, 0, -puck4.vel.z);
				}
			}*/

			function animate() {
				var start  = clock.startTime;
				var old = clock.oldTime;
				var dt = clock.getDelta();
				var dt2 = clock.getDelta() + 0.02;
				var dt3 = clock.getDelta() + 0.03;
				var dt4 = clock.getDelta() + 0.04;
				//pos.add(vel.clone().multiplyScalar(dt));//pos(t+dt) = pos(t) + vel(t) * dt
				
				if((old-start)/1000 > 5.0){
					scene.add(puck2.mesh);
					pointLight2.position.set(puck2.pos.x, 10, puck2.pos.z);
					pointLight2.color = pColor;
					mesh2.position.set(55, 15, 105);
					mesh5.position.set(-55, 15, 105);
					mesh.position.set(55, 15, -105);
					mesh6.position.set(-55, 15, -105);
					
				}
				//console.log("%f", old-start);
				if((old-start)/1000 > 10.0){
					scene.add(puck3.mesh);
					pointLight3.position.set(puck3.pos.x, 10, puck3.pos.z);
					pointLight3.color = pColor;
					mesh2.position.set(115, 15, 105);
					mesh5.position.set(-115, 15, 105);
					mesh.position.set(115, 15, -105);
					mesh6.position.set(-115, 15, -105);
				}
				if((old-start)/1000 > 15.0){
					scene.add(puck4.mesh);
					pointLight4.position.set(puck4.pos.x, 10, puck4.pos.z);
					pointLight4.color = pColor;
					mesh2.position.set(145, 15, 105);
					mesh5.position.set(-145, 15, 105);
					mesh.position.set(145, 15, -105);
					mesh6.position.set(-145, 15, -105);
				}
				
				puck.update(dt);
				puck.collision();
				puck2.update(dt2);
				puck2.collision();
				puck3.update(dt3);
				puck3.collision();
				puck4.update(dt4);
				puck4.collision();
				
				//coll();
				
				pointLight.position.set(puck.pos.x, 10, puck.pos.z);
				pointLight.color = pColor;
				
				
				
				
				
				
				

				controls.update();

				requestAnimationFrame(animate);
				render();
			}

			function render() {
				var delta = clock.getDelta();
				meshMaterial.uniforms.time.value += delta * 400;
				meshMaterial2.uniforms.time.value += delta * 400;
				meshMaterial3.uniforms.time.value += delta * 400;
				meshMaterial4.uniforms.time.value += delta * 400;
				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>