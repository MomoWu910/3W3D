<!DOCTYPE html>
<html>
	<head>
		<style>
			
			#container {
				width: 45vw;
				height: 45vw;
				float:left;
				background-color:pink;
				margin: 10px;
			}
			#cnvsFrame {
				height: 0;
				padding-bottom:100%;
			}

			.fl {
				float:left;
				margin:20px;
			}
			.flc {
				float:right;
				margin:5px;
				width:30%;
			}
			body {
				overflow: auto;
			}
			
		</style>
	</head>

	<body> 

		<h1> 點選畫面左邊1~3號(左至右)之一，再點選畫面右邊名畫即可變更 </h1>
		<div>
			<button id="setValueBtn" onclick="javascript:save_click()">
				儲存狀態
			</button>
			
			<button id="getValueBtn" onclick="javascript:load_click()">
				載入狀態
			</button>
		</div>

		
		<hr>
		<div id="container">
			
			<canvas id="cnvs"> </canvas>
			
		</div>
		
		<div style=" margin: 10px; width:30%; height:25%; float:right">
			1.<img src="http://i.imgur.com/3cS5EDQ.jpg" class="flc" onclick="javascript:tst(1);" />
		</div>	
		<div style=" margin: 10px; width:30%; height:25%; float:right">
			2.<img src="http://i.imgur.com/D1oCtpi.jpg" class="flc" onclick="javascript:tst(2);" />
		</div>	
		<div style=" margin: 10px; width:30%; height:25%; float:right">
			3.<img src="http://i.imgur.com/i4wsYkE.jpg" class="flc" onclick="javascript:tst(3);" />
		</div>	
		<div style=" margin: 10px; width:30%; height:25%; float:right">
			4.<img src="http://i.imgur.com/Sjdcyvy.jpg" class="flc" onclick="javascript:tst(4);" />
		</div>
		<div style="clear:both"></div>
		<hr>
		
			
			
		<script src="js/three.min.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/KeyboardState.js"></script>
		<script src="js/loaders/MTLLoader.js"></script>
		<script src="js/loaders/OBJMTLLoader.js"></script>
		
		
		<script>

			var camera, scene, renderer, geometry, material, mesh, mesh2, mesh3, meshtemp, light, controls;
			var wall, wall2, wall3;
			var tex1, tex2, tex3, tex4;
			var raycaster;
			var mouse = new THREE.Vector2();
			var pickables = [];
			var theCanvas, theCanvasFrame;
			var status = [];
			var myVal = [];
			
			init();
			animate();
			
			function save_click(){
				
				localStorage.setItem("myVal", status);
			};

			function load_click(){
				status = localStorage.getItem("myVal");
				alert(myVal);
				
				if(status[0] == 1){meshtemp = 1;tst(1);}
				else if(status[0] == 2){meshtemp = 1;tst(2);}
				else if(status[0] == 3){meshtemp = 1;tst(3);}
				else if(status[0] == 4){meshtemp = 1;tst(4);}
				
				if(status[1] == 1){meshtemp = 2;tst(1);}
				else if(status[1] == 2){meshtemp = 2;tst(2);}
				else if(status[1] == 3){meshtemp = 2;tst(3);}
				else if(status[1] == 4){meshtemp = 2;tst(4);}
				
				if(status[2] == 1){meshtemp = 3;tst(1);}
				else if(status[2] == 2){meshtemp = 3;tst(2);}
				else if(status[2] == 3){meshtemp = 3;tst(3);}
				else if(status[2] == 4){meshtemp = 3;tst(4);}
					
				
			};

			function init() {
				theCanvas = document.getElementById("cnvs");
				theCanvasFrame = document.getElementById("container");

				renderer = new THREE.WebGLRenderer({
					canvas: theCanvas,
					antialias: true
				});
				var ww = theCanvasFrame.clientWidth;
				var hh = theCanvasFrame.clientHeight;
				renderer.setSize(ww, hh);
				renderer.setClearColor(0x555555);

				scene = new THREE.Scene();
				

				camera = new THREE.PerspectiveCamera(50, ww/hh, 1, 1000);
				camera.position.z = 200;
				scene.add(camera);

				//////////////////////////////////////////////////////
				THREE.ImageUtils.crossOrigin = '';
				tex1 = THREE.ImageUtils.loadTexture('http://i.imgur.com/3cS5EDQ.jpg');
				tex2 = THREE.ImageUtils.loadTexture('http://i.imgur.com/D1oCtpi.jpg');
				tex3 = THREE.ImageUtils.loadTexture('http://i.imgur.com/i4wsYkE.jpg');
				tex4 = THREE.ImageUtils.loadTexture('http://i.imgur.com/Sjdcyvy.jpg');
				var floormap = THREE.ImageUtils.loadTexture('http://i.imgur.com/HqQ3gul.jpg');
				var wallmap = THREE.ImageUtils.loadTexture('http://i.imgur.com/lK8LqnX.jpg');
				var drawmap = THREE.ImageUtils.loadTexture('http://i.imgur.com/Mj4xcn1.jpg');
				
				geometry = new THREE.PlaneGeometry(60, 50);
				material = new THREE.MeshLambertMaterial({
						map:drawmap,
						side: THREE.DoubleSide
				});
					

				
				
				mesh = new THREE.Mesh(geometry, material);
				mesh.position.x = -35;
				mesh.position.y = 10;
				mesh.position.z = -35;
				
				mesh2 = new THREE.Mesh(geometry, material);
				mesh2.position.x = 35;
				mesh2.position.y = 10;
				mesh2.position.z = -35;
				
				mesh3 = new THREE.Mesh(geometry, material);
				mesh3.rotation.y = -Math.PI/2;
				mesh3.position.x = 70;
				mesh3.position.y = 10;
				mesh3.position.z = 10;
				scene.add(mesh);
				scene.add(mesh2);
				scene.add(mesh3);

				
				pickables = [mesh, mesh2, mesh3];
				mesh.name = "mesh";
				mesh2.name = "mesh2";
				mesh3.name = "mesh3";
				
				
				
				geometry2 = new THREE.PlaneGeometry(70, 60);
				material2 = new THREE.MeshLambertMaterial({
					map: wallmap,
					side: THREE.DoubleSide,
					polygonOffset: true,
					polygonOffsetFactor: 0.5
				});
				
				wall = new THREE.Mesh(geometry2, material2);
				wall.position.x = -35;
				wall.position.y = 10;
				wall.position.z = -35;
				
				wall2 = new THREE.Mesh(geometry2, material2);
				wall2.position.x = 35;
				wall2.position.y = 10;
				wall2.position.z = -35;
				
				wall3 = new THREE.Mesh(geometry2, material2);
				wall3.rotation.y = Math.PI/2;
				wall3.position.x = 70;
				wall3.position.y = 10;
				wall3.position.z = 10;
				scene.add(wall);
				scene.add(wall2);
				scene.add(wall3);
				
				light = new THREE.PointLight(0xffffff);
				light.position.set(-100, 300, 200);
				scene.add(light);

				/*var gridXZ = new THREE.GridHelper(100, 10);
				gridXZ.setColors(new THREE.Color(0xff0000), new THREE.Color(0xffffff));
				gridXZ.position.y = -25;
				scene.add(gridXZ);*/
				
				var floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200),
				new THREE.MeshLambertMaterial({map: floormap}));
				floor.rotation.x = -Math.PI / 2;
				floor.position.y = -20;
				scene.add(floor);

				controls = new THREE.OrbitControls(camera, renderer.domElement);
				document.addEventListener ('resize', onWindowResize, false); 

				// the following is not needed for "embed" mode
				//document.body.appendChild(renderer.domElement);
				raycaster = new THREE.Raycaster();
				document.addEventListener('mousedown', onDocumentMouseDown, false);
				document.addEventListener('mousemove', onDocumentMouseMove, false);
			}

			function onDocumentMouseDown(event) {

				// PICKING DETAILS: 
				// convert mouse.xy = [-1,1]^2 (NDC)
				// unproject (mouse.xy, 1) to a point on the far plane (in world coordinate)
				// set raycaster (origin, direction)
				// find intersection objects, (closest first) 
				// each record as
				// [ { distance, point, face, faceIndex, object }, ... ]

				event.preventDefault();
				mouse.x = ( (event.clientX - event.target.offsetLeft) / theCanvasFrame.clientWidth ) * 2 - 1;
				mouse.y = - ( (event.clientY - event.target.offsetTop) / theCanvasFrame.clientHeight ) * 2 + 1;

				// find intersections
				var vector = new THREE.Vector3(mouse.x, mouse.y, 1).unproject(camera);
				raycaster.set(camera.position, vector.sub(camera.position).normalize());
				var intersects = raycaster.intersectObjects(pickables);
				if (intersects.length > 0) {
				
					if (intersects[0].object.name === "mesh") meshtemp = 1;
					else if (intersects[0].object.name === "mesh2") meshtemp = 2;
					else if (intersects[0].object.name === "mesh3") meshtemp = 3;

				}

			}

			function onDocumentMouseMove(event) {
				event.preventDefault();
				mouse.x = ( (event.clientX - event.target.offsetLeft) / theCanvasFrame.clientWidth ) * 2 - 1;
				mouse.y = - ( (event.clientY - event.target.offsetTop) / theCanvasFrame.clientHeight ) * 2 + 1;
				//
				var vector = new THREE.Vector3(mouse.x, mouse.y, 1).unproject(camera);
				raycaster.set(camera.position, vector.sub(camera.position).normalize());
				var intersects = raycaster.intersectObjects(pickables);

				if (intersects.length > 0) {
					document.body.style.cursor = 'pointer';
				} else {
					document.body.style.cursor = 'auto';
				}
			}
			// remember "no warp in <body>"
			//
			function tst(which) {

				if (which === 1) {
					if (meshtemp === 1){
						mesh.material = new THREE.MeshBasicMaterial({
							map: tex1
						});
						status[0] = 1;
					}else if (meshtemp === 2){
						mesh2.material = new THREE.MeshBasicMaterial({
							map: tex1
						});
						status[1] = 1;
					}else if (meshtemp === 3){
						mesh3.material = new THREE.MeshBasicMaterial({
							map: tex1
						});
						status[2] = 1;
					}
				} else if (which === 2) {
					if (meshtemp === 1){
						mesh.material = new THREE.MeshBasicMaterial({
							map: tex2
						});
						status[0] = 2;
					}else if (meshtemp === 2){
						mesh2.material = new THREE.MeshBasicMaterial({
							map: tex2
						});
						status[1] = 2;
					}else if (meshtemp === 3){
						mesh3.material = new THREE.MeshBasicMaterial({
							map: tex2
						});
						status[2] = 2;
					}
				}else if (which === 3) {
					if (meshtemp === 1){
						mesh.material = new THREE.MeshBasicMaterial({
							map: tex3
						});
						status[0] = 3;
					}else if (meshtemp === 2){
						mesh2.material = new THREE.MeshBasicMaterial({
							map: tex3
						});
						status[1] = 3;
					}else if (meshtemp === 3){
						mesh3.material = new THREE.MeshBasicMaterial({
							map: tex3
						});
						status[2] = 3;
					}
				}else if (which === 4) {
					if (meshtemp === 1){
						mesh.material = new THREE.MeshBasicMaterial({
							map: tex4
						});
						status[0] = 4;
					}else if (meshtemp === 2){
						mesh2.material = new THREE.MeshBasicMaterial({
							map: tex4
						});
						status[1] = 4;
					}else if (meshtemp === 3){
						mesh3.material = new THREE.MeshBasicMaterial({
							map: tex4
						});
						status[2] = 4;
					}
				}
				
				// debugger;
			}

			function animate() {
				controls.update();

				requestAnimationFrame(animate);
				render();
			}

			function render() {
				renderer.render(scene, camera);
			}
			function onWindowResize ()
			{
				var ww = theCanvasFrame.clientWidth;
				var hh = theCanvasFrame.clientHeight;
				camera.aspect = ww/hh;
				camera.updateProjectionMatrix();
				renderer.setSize (ww,hh);
			}
			window.focus();
		</script>
	</body>

</html>